---
layout: post
title:      "Learning to Love Javascript by diving in to AJAX"
date:       2018-10-09 18:49:35 +0000
permalink:  learning_to_love_javascript_by_diving_in_to_ajax
---

[Originally posted on Medium ](https://medium.com/@kristenleach24/learning-to-love-javascript-by-diving-in-to-ajax-75640ca4c433)

I’m almost done with the Flatiron School curriculum! One of my final projects was taking my existing Rails app and adding Javascript and AJAX for asynchronous page rendering. I went into this project feeling totally lost; I felt unprepared. The task SEEMS daunting at face-value, and in some ways it is. AJAX is doing some really intricate stuff behind the scenes, and I didn’t really feel like I understood the ins and outs before beginning this project. I relied heavily on help from others at the beginning, but by the end I was debugging and writing code like it was my job (which it will be)! Getting started is always the hardest part.

The first thing I decided to begin with also ended up being the hardest; submitting my heart button through AJAX. I used a Font Awesome icon as the button, which rely on CSS classes to render their images. One was an empty heart, the other was a black heart. I had to figure out how to submit the post request to create a heart, change the CSS class of that heart, and then change the action on that heart to a delete action so that if the user clicked again it would submit a delete request. Likely the most difficult bug to find and fix was due to the listeners. Somehow, my program was attaching multiple event listeners to the heart buttons. When I clicked on one to submit, I would get a 422 error, and the heart would be created after I refreshed the page, but the change in the heart class was not loading asynchronously. My program was submitting the form and following through with the object creation, but it was then trying to submit the form AGAIN; which threw an error due to validations I have set up (a user can only have one heart on a recipe to ensure the objects are deleted properly). To fix this, in my attachListeners function I added an ‘.unbind(“click”)’ before setting my own click event, so that if for some reason multiple were being added, the first would be unbound and only the second would fire.

The next requirement I worked on fixing was setting up the three index pages to render via AJAX. One page included all recipes, another included all the recipes currently added to meal plans or “popular recipes,” and the third included all of the recipes the current user had hearted. This turned out to be a much simpler task overall; it was just a matter of adding the same class to each link and having them submit a getJSON request to the server. I did have some trouble in this section with building out the HTML versions of my rails forms; especially with the heart button form. I had to create two different forms (one to delete, one to post) and toggle between the two based on whether the current user had a heart on each individual recipe. This is where I ended up having to pass the current user’s ID (created with a ruby method) through a body data tag in the HTML so that I could only show the recipes that the current user liked, not all recipes liked by any user. This current user ID came in handy throughout the rest of my project; I used it several times and expect it will be a trick I continue to use on other projects.

A similar requirement was the need to build out AJAX pagination functionality for a list of items. I used it on my recipe show pages, beginning on any one page you can scroll through the recipes and look at each one. This was by far the easiest part of this project; it didn’t require building out HTML forms or submitting forms of any kind! Phew. All I needed to do was to update the buttons on each page to direct to either the next or previous recipe based on the recipe id. What I didn’t realize was that I had some typos in my pagination file. One typo prevented the pagination from firing at all, and when that one was fixed the heart buttons broke. I had to fix the HTML form (those freaking HTML forms), but luckily it was a quick fix.


Ugh. Typos.
The final requirement of this project included building out a has-many relationship that rendered with AJAX. I decided to add comments and render the list of comments or a new comment with AJAX. I had to do this section from scratch since I did not already have comment functionality, so I saved this portion for last. Once I created a comment model and got the functionality working with Rails alone, I added the javascript. I created a comment model object, and built out the li item for each comment. Then I set up the page to render all of the comments if “Show Comments” is clicked, OR if a user submits a comment. The JS first creates a new comment on submit, then calls showComments() to render the list. Comments are shown with the time created, but I am not sure I like the format I chose to use with the javascript Date() object, and I may come back later to reformat it using moment.js.

I feel like I learned more from this project than previous projects, which seems to be the pattern. Javascript is such an integral part of programming these days and I left the lessons feeling like I was a catastrophic failure of a developer. Now I feel like I get it. I know I still have a lot to learn when it comes to AJAX and JS, and I really want to practice more with Fetch.

Overall, lesson learned; when I am feeling defeated, I just need to code more. That’s how I get better.# Enter your title here

The content of your blog post goes here.
