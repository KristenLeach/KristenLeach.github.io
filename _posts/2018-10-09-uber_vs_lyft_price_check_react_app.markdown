---
layout: post
title:      "Uber vs. Lyft: Price Check React App"
date:       2018-10-09 18:50:41 +0000
permalink:  uber_vs_lyft_price_check_react_app
---


[Originally posted on Medium](https://medium.com/@kristenleach24/uber-vs-lyft-price-check-react-app-3ed5eedc66a8)

As a web developer, the way I tend to approach app ideas is by examining my own day to day tasks and evaluating how I could use technology to streamline them. A few months ago my husband and I needed to order an Uber, and my first thought was, “how do we know if Lyft would be cheaper?” You can get a price estimate before you book a ride, but to have to request an estimate from each app eats up a lot of time. It was then that I decided I wanted to build an app that would do all of that price comparison work for me. The idea was to be able to input a starting location and destination, check a map component for geocoding accuracy, and then be given both Uber and Lyft’s full range of ride-types and current estimates so that you could avoid paying more for the same ride.

The first step in building this app was tacking the input areas for starting and ending locations. While I could have built and styled my own input fields for this, I didn’t want to spend too much time on styling, so I opted to import pre-styled field components from Semantic-UI. Importing them was one thing; basically I just wrapped the component in my own component; just as I would an HTML input field. However, Semantic-UI components come with so many preset props and options so you can really customize them. Finding the names/values of these could be a little tricky at first. In the end, learning to read through their docs was really helpful, and translated to reading through the docs for Google, Uber, and Lyft’s APIs as I continued to build.


I was hoping to use Google Places Autocomplete function as the user typed their location into the dropdown input area, but I learned that in doing so I would be charging something like $.012 cents to my account for every letter typed. Out of fear of reaching the limit on free requests, I opted to have the Places API only fill in the suggested locations after the user typed out a general location and hit submit. That way, the API was only being hit a single time and I prevent any crazy request flooding to my API key. I have the input component set up now with its own state, the starting/ending locations. When submitted, that string is sent to Google Places, which sends back an array of 5 suggested locations. Those locations are stored in redux, then mapped through in my search component to display as a dropdown menu. When the user selects one of the dropdown menu locations, it updates the local component state to hold the official address. When both locations are searched and stored as a Google Places location, the form is submitted to the next page.


The next page would hold a simple map component that charted the two locations to make sure they were correct. All mapping in this sense must be done with geocoded coordinates, which was something I learned during this project. Directions; ride requests; map displays etc. all function through geocoded coordinates instead of street addresses. The problem with that is that geocoding happens to also be a very expensive and tedious task, with Google’s geocode requests coming in at $.50 EACH. Wanting to avoid an accidental overcharge on my account, I did my best to try another geocoding service. I found MapBox to be much cheaper, but also very inaccurate when being used with Google’s Places search. Their autocomplete places search was also inaccurate; as Google’s comes with a built-in location binder and MapBox does not. If I searched for “Ferry Building” with Google’s API, the suggested locations knew from my IP address I was near San Francisco thus only showed me results for Ferry Building in my general area. Mapbox showed Pennsylvania, Massachusetts, even something in South America for the same search. In order to go back and use their mapping services, I would have had to add another field that made the user input their city/state, submit that to set up a binding area, and then allow them to search for their start/end locations. Not only did that feel like a lot of unnecessary work to get the results I wanted, but the flow on the page would have really messed with the UI/UX I was going for.


In the end, I stuck with Google’s geocoder and just decided I won’t be publishing this app for public use yet to prevent those charges from building up. I did, however, use MapBox’s Map component, as I found their React package to be really clean and easy to use. The only issue I had with it was getting their location markers working. It seems it is a common issue that many of the icons they offer for these markers just don’t even show up. I tried quite a few, but ended up having to go with little stars, just because I can at least see them on the page. I would like to be able to change the colors of them (they defaulted to brown), but I have yet to be able to get that working either.

So, the user has submitted their start/end locations, Google's geocoding API works its magic, and the locations are shown on a map component on the next route. If correct, the user can move forward to the Uber/Lyft portion, if not there is a button that allows you to move back and enter new locations. An unfortunate reality is that the Google geocode API working with MapBox is still not 100% accurate, and on occasion one location just won’t show up on the map. I believe that is an error on the mapping side since typically the requests can still be sent to Uber/Lyft with a response. This means those geocoded locations are *there*, they just can’t be shown on the map. Since this app isn’t going straight to production I’ll just save that for another day.

The final route is where the magic happens. Those coordinates from the map are sent to both Uber and Lyft simultaneously. I got to implement some async/await into those fetch methods to make sure my components would update correctly, which was fun. I’ve heard about async/await, but I’d yet to have a chance to try them out until now. Once both fetch requests have been completed, the components update with the price estimates for each ride-type (Uber X, Shared, Uber Black, etc.), and the current estimate range for each type. It would be nice if their API’s returned a dollar estimate, but both return a range most often. Lyft’s estimate is returned in cents, so I had to tack on another function that mapped through the results and converted them to a more readable cost. Instead of 1900 to 2000 cents, I saved their estimates as “$19–20” to match Uber’s format. After that, the only issue left with the client side was to be sure the two results components load at the same time, which involved added a loader to the component that would run while both results were uploaded. Et, voila!


This project was complicated for a few reasons; it was a lot of API calls and handling of outside data. There was also a lot of very particular UI/UX functions I wanted to implement that involved passing redux state across routes, using Semantic-UI components, and styling. But overall, it went pretty smoothly. It is a very small app overall in terms of usage, but the backend is bulky and really strong. It’s pretty cool to be able to build an app that serves a real purpose and can help people save money. Now I need to figure out how to avoid racking up tens of thousands of dollars in API charges by making this a public mobile app.
